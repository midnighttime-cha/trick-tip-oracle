
# SQL for Oracle

## Get all column name
```sql
SELECT table_name, column_name, data_type, data_length
FROM USER_TAB_COLUMNS
WHERE table_name = 'MYTABLE'
```

## Table Modify
```sql
ALTER TABLE TEST_PROJECT2 MODIFY proj_name VARCHAR2(300);
```

## Reset password sys
```bash
sqlplus /nolog
connect / as sysdba
```
next
```sql
ALTER USER sys IDENTIFIED BY "new_password";
```
## Get sequence next value
```sql
SELECT "APP_DBA"."TABLE_TEST_SEQ".nextval ID FROM DUAL
```

## Get sequence last value
```sql
SELECT last_number
FROM user_sequences
WHERE sequence_name = 'TABLE_TEST_SEQ';
```

## Reset sequence last value
```sql
ALTER SEQUENCE TABLE_TEST_SEQ RESTART START WITH 10;
```
or
```sql
ALTER TABLE <SCHEMA>.<TABLE_NAME> MODIFY ID GENERATED BY DEFAULT ON NULL AS IDENTITY(START WITH 100);
```
## Instance

### Selct instance
```sql
select instance_name from v$instance;
select version from v$instance;
```


## Tablespace

### DROP TABLESPACE and TEMPORARY

Delete Tablespace
```sql
DROP TABLESPACE tbs_01 
    INCLUDING CONTENTS 
        CASCADE CONSTRAINTS;
```

Delete tablespace and datafile
```sql
DROP TABLESPACE tbs_02
   INCLUDING CONTENTS AND DATAFILES;
```



# รวมการแก้ปัญหา Oracle 12c

## ORA-28014: Cannot Drop Administrative Users
```sql
ALTER SESSION SET "_oracle_script"=true;
DROP USER TEST_DBA CASCADE;
```

## ORA-65096: invalid common user or role name
```sql
ALTER SESSION SET "_oracle_script"=true;
CREATE USER EX_DBA IDENTIFIED BY 12345;
```

## ORA-01940: cannot drop a user that is currently connected
```sql
SELECT s.sid, s.serial#, s.status, p.spid FROM v$session s, v$process p WHERE s.username = 'TEST_DBA' AND p.addr(+) = s.paddr;
# Output

```
next
```sql
ALTER SYSTEM KILL SESSION '<SID>, <SERIAL>';
```


## CREATE TABLESPACE
```sh
CREATE TABLESPACE DATA_EX DATAFILE '/home/oracle/oradata/DATAFILE/DATA_EX01.dbf' SIZE 4096M AUTOEXTEND ON NEXT 100M EXTENT MANAGEMENT LOCAL UNIFORM SIZE 1M;
```

## CREATE TEMPORARY
```sh
CREATE TEMPORARY TABLESPACE TEMP_EX TEMPFILE '/home/oracle/oradata/DATAFILE/TEMP_EX01.dbf' SIZE 3G EXTENT MANAGEMENT LOCAL UNIFORM SIZE 1M;
```

## GRANT DBA
```sh
GRANT RESOURCE,CONNECT TO EX_DBA;
```
Optional
```sql
GRANT EXP_FULL_DATABASE TO EX_DBA;
GRANT IMP_FULL_DATABASE TO EX_DBA;
GRANT CREATE ANY DIRECTORY TO EX_DBA;
```

## CREATE/ALTER USER
```bash
CREATE USER EX_DBA IDENTIFIED BY Test12345 DEFAULT TABLESPACE DATA_EX TEMPORARY YABLESPACE TEMP_EX;

#or

ALTER USER TEST_DBA DEFAULT TABLESPACE DATA_EX;
ALTER USER TEST_DBA TEMPORARY TABLESPACE TEMP_EX;
```
## EXPORT DATAPUMP
```sh
expdp system/SystemPass@XE directory=DATA_PUMP_DIR dumpfile=DATA_EXAMPLE.DMP logfile=DATA_EXAMPLE.log schemas=DATA_EXAMPLE
```

## IMPORT DATAPUMP
```sh
impdp system/SystemPass@XE directory=DATA_PUMP_DIR dumpfile=DATA_EXAMPLE.DMP logfile=DATA_EXAMPLE.log schemas=DATA_EXAMPLE
```

## SHOW DIRECTORY
```sh
SELECT * FROM DBA_DIRECTORIES;
```

## Oracle Not available
1. Check the Listener Status
```
lsnrctl status

lsnrctl start
```

2. Manually Register the Service
Step 1: Login to the database as SYSDBA
```
sqlplus / as sysdba
```
Step 2: Set Dynamic Registration
```sql
ALTER SYSTEM REGISTER;
```
Step 3: Restart the Listener
```
lsnrctl stop
lsnrctl start
```
Step 4: Restart the Database (if needed)
```sql
shutdown immediate;
startup;
```
3. Verify tnsnames.ora
Check your tnsnames.ora file to ensure the service name [SID] is correctly defined.
```sh
$ORACLE_HOME/network/admin/tnsnames.ora
```
example output:
```
TESTDB1 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.99)(PORT = 1521))
    (CONNECT_DATA =
      (SERVICE_NAME = TESTDB1)
    )
  )
```
If it is incorrect, update the tnsnames.ora file, save it, and reload:
```
tnsping TESTDB1
```
If tnsping fails, there is still an issue with the service name.
4. Ensure the PDB is Open (for Pluggable Databases)
```sql
ALTER PLUGGABLE DATABASE TESTDB1 OPEN;
```
Then force it to register:
```sql
ALTER SYSTEM REGISTER;
```

Grant สิทธิ์สำหรับ Reference ข้าม Schema
```sql
BEGIN
  FOR t IN (SELECT table_name FROM all_tables WHERE owner = 'TEST_DBA1') LOOP
    EXECUTE IMMEDIATE 'GRANT SELECT, REFERENCES ON TEST_DBA1.' || t.table_name || ' TO TEST_DBA2';
  END LOOP;
END;
```

## CREATE DIRECTORY
```sql
CREATE DIRECTORY data_pump_dir AS '/path/to/your/directory';
```

## Tuning
ตรวจสอบ
```sql
SELECT COMPONENT, CURRENT_SIZE, MIN_SIZE, MAX_SIZE
FROM V$SGA_DYNAMIC_COMPONENTS;
```

1. ปรับ Database Buffer Cache
ค่าปกติของ Database Buffer Cache ขึ้นอยู่กับ SGA_TARGET ถ้าเปิดใช้ AUTO MEMORY MANAGEMENT
หากต้องการกำหนดเอง ให้ใช้คำสั่ง:
```sql
ALTER SYSTEM SET DB_CACHE_SIZE = 1G SCOPE=BOTH;
```
(512M สามารถเปลี่ยนเป็นค่าที่ต้องการ เช่น 1G หรือ 256M)

2. ปรับ Shared Pool Size
หาก SQL Execution ใช้เวลานาน หรือมีการ Compile PL/SQL บ่อย ๆ ให้เพิ่มขนาด Shared Pool
```sql
ALTER SYSTEM SET SHARED_POOL_SIZE = 256M SCOPE=BOTH;
```

3. ปรับ Redo Log Buffer Size
หากมีการเขียนข้อมูลหนัก (INSERT, UPDATE, DELETE) อาจต้องเพิ่ม Redo Log Buffer
```
ALTER SYSTEM SET LOG_BUFFER = 32M SCOPE=SPFILE;
```
(ต้อง Restart Database หลังจากเปลี่ยนค่าของ LOG_BUFFER)

4. เปิดใช้งาน Automatic Memory Management (AMM)
ถ้าไม่ต้องการตั้งค่าทีละตัว สามารถเปิดใช้ Automatic Memory Management (AMM)
```sql
ALTER SYSTEM SET MEMORY_TARGET = 2G SCOPE=SPFILE;
ALTER SYSTEM SET MEMORY_MAX_TARGET = 2G SCOPE=SPFILE;
```
(ค่าขึ้นอยู่กับ RAM ของเครื่อง เช่น 4G, 8G)

5. ใช้คำสั่ง SQL นี้เพื่อตรวจสอบ Cache Hit Ratio
```sql
SELECT NAME, VALUE
FROM V$SYSSTAT
WHERE NAME IN ('db block gets', 'consistent gets', 'physical reads');
```

จากนั้นคำนวณ Buffer Cache Hit Ratio:
```sql
SELECT (1 - (phy.value / (cur.value + con.value))) * 100 AS "Buffer Cache Hit Ratio"
FROM V$SYSSTAT cur, V$SYSSTAT con, V$SYSSTAT phy
WHERE cur.name = 'db block gets'
AND con.name = 'consistent gets'
AND phy.name = 'physical reads';
```
ค่า Buffer Cache Hit Ratio ควรอยู่ที่ > 90% ถ้าต่ำกว่า ควรเพิ่ม DB_CACHE_SIZE

6. ปรับใช้ Keep Pool และ Recycle Pool (Optional)
ถ้าต้องการให้ข้อมูลบางส่วนอยู่ใน Cache นานขึ้น หรือให้ล้าง Cache บางส่วนเร็วขึ้น
- สร้าง Keep Pool สำหรับ Table ที่ต้องการเก็บใน Cache ตลอด
```sql
ALTER SYSTEM SET DB_KEEP_CACHE_SIZE = 128M;
ALTER TABLE important_table STORAGE (BUFFER_POOL KEEP);
```
- สร้าง Recycle Pool สำหรับ Table ที่ไม่ต้องการเก็บใน Cache นาน
```sql
ALTER SYSTEM SET DB_RECYCLE_CACHE_SIZE = 64M;
ALTER TABLE log_table STORAGE (BUFFER_POOL RECYCLE);
```

7. Restart Database เพื่อใช้ค่าที่เปลี่ยนแปลง
```sql
SHUTDOWN IMMEDIATE;
STARTUP;
```
